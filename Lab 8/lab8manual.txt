For this lab, you will implement all three portions of the Moore model - the next-state logic, state machine, and output logic. The next-state will depend only on the three bits of the current state. An easy way to implement a three-variable logic function is to use a 3-to-8 decoder. When the decoder has active-low outputs, the inverted minterms can be summed with NAND gates. This is very similar to what you did for lab 5 when you implemented eight unique logic functions.

Implement these functions in the top module of your design as follows:

Represent the state with a three-bit logic bus named 'q'.
Represent the "next-state" with a three-bit logic bus named 'next_q'.
Represent the output logic with a 2 bit logic bus named 'f'.
Rather than using discrete structural flip-flops, use an always_ff block to update the 'q' bus as follows:
Use pb[1] as an asynchronous reset signal. It should set the state of the three flip-flops to the value specified below. As long as pb[1] is asserted, the state of the flip-flops will retain this value regardless of the actions of the clock signal.
Use pb[0] as a clock signal. As long as pb[1] is not asserted, it should set the 'q' logic bus to 'next_q'.
Add the SystemVerilog model of the 74HC138 to your design. Create one instance of it, connect its 'a' inputs to the state 'q', and wire its 'e' enable pins to allow exactly one of its outputs to be active all the time. Connect an 8-bit logic bus named 'p' (product terms) to the 'y' output of the decoder.
Add the SystemVerilog model of the 74HC151 to your design. Create two instances of it. For the first instance, connect the 'i' input to the value represented by your first lookup table, the 's' input to 'q', and the 'z' output to 'f[0]'. For the second instance, connect the 'i' input to the value represented by your second lookup table, the 's' input to 'q', and the 'z' output to 'f[1]'. Make sure to connect both instances' 'e' enable pins to a logic high.
Connect each of the three elements of the 'next_q' bus to the output of a four-input dataflow NAND expression. Each input of the NAND will be one of the elements of the 'p' bus — the inverted product terms generated by the decoder.
Connect the 'q' bus to right[2:0] for observation.
Connect the 'next_q' bus to left[2:0] for observation.
Connect the 'f' bus to right[7:6] for observation.
Your top module should look something like this:
module top(...);
    logic [2:0] q;
    logic [2:0] next_q;
    logic [1:0] f;
    always_ff @( ... )
        ...
    logic [7:0] p;
    hc138 decode(.a(q), .e1(0), .e2(0), .e3(1), .y(p));
    hc151 mux1(.i(...), .s(q), .e(1), .z(f[0]));
    hc151 mux2(.i(...), .s(q), .e(1), .z(f[1]));
    assign next_q[0] = ...
    assign next_q[1] = ...
    assign next_q[2] = ...
    assign right[2:0] = ...
    assign left[2:0] = ...
    assign right[7:6] = f;
endmodule
Your next-state function, reset value and lookup table values
Just as with lab 5, you will implement a unique next-state block, reset value, and output logic for your design. Your next-state table is as follows:

   q   	next_q
0	2
1	3
2	1
3	6
4	7
5	4
6	5
7	0

Your reset value is 1.

Your first lookup table expression is X·Y·Z' + X·Y'·Z + X'·Y·Z' + X'·Y'·Z + X'·Y'·Z'.

Your second lookup table expression is X·Y·Z + X'·Y·Z + X'·Y·Z'.
Test your system. Ensure that holding down the '1' button immediately forces the 'q' state to the reset value shown above, and the output logic selects the corresponding bits from both the lookup tables. As long as the '1' button is pressed, 'q' should remain set to the reset value regardless of the activity on the clock. When the '1' button is released, each press of the '0' button should immediately cause 'q' to change to 'next_q'. Pressing the '0' button eight times will follow one full cycle of the state back to the starting value.